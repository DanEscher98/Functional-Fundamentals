<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Daniel Sanchez" />
  <title>Monads introduction</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Monads introduction</h1>
<p class="author">Daniel Sanchez</p>
</header>
<h2 id="definition">Definition</h2>
<p>A monad is an algebraic structure in category theory. In Haskell it is used to describe computations as sequences of steps, and to handle side effects such as state and IO. When dealing with values with context, Monad type-class helps us by automatically handling the context for us.</p>
<p>A monad consists of three objects, which must satisfy the <em>monad laws</em>.</p>
<h2 id="whats-the-point-of-monads">Whatâ€™s the point of monads?</h2>
<ol type="1">
<li>Supports <em>pure</em> programming with <em>effects</em>.</li>
<li>Use of monads is <em>explicit</em> in types.</li>
<li>Can generalise functions to <em>any</em> effect.</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Type</strong></th>
<th style="text-align: left;"><strong>Effect</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>a -&gt; Maybe b</code></td>
<td style="text-align: left;">Exceptions</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>a -&gt; List b</code></td>
<td style="text-align: left;">Non-determinism</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>a -&gt; ST b</code></td>
<td style="text-align: left;">Internal state</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>a -&gt; IO b</code></td>
<td style="text-align: left;">Input/Output</td>
</tr>
</tbody>
</table>
<h2 id="the-three-basic-objects">The three basic objects</h2>
<ul>
<li>A type constructor <strong>M</strong>, such that for any type <strong>a</strong>, the type <strong>M a</strong> is the type of a computation in the monad <strong>M</strong> that produces a result of type <strong>a</strong>.</li>
<li>The bind operator (<code>&gt;&gt;=</code>). A function that takes two computations and performs them one after the other, making the result of the first computation available to the second.</li>
<li>The return function <code>return</code>. A function such that if <strong>x::a</strong>, then <strong>return x</strong> is a computation in <strong>M</strong> that, when executed will produce a value of type <strong>a</strong>.</li>
</ul>
<h2 id="the-monad-type-class">The Monad type class</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span><span class="ot">  ::</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=)   ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b <span class="co">-- bind</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;)    ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b        <span class="co">-- then</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- m &gt;&gt; n = m &gt;&gt;= _ -&gt; n</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">fail</span><span class="ot">    ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m a</span></code></pre></div>
<h2 id="the-monad-laws">The Monad Laws</h2>
<ul>
<li>The <em>right unit law</em>: <code>m &gt;&gt;= return</code> equates to <code>m</code></li>
<li>The <em>left unit law</em>: <code>return x &gt;&gt;= f</code> equates to <code>f x</code></li>
<li>The <em>associativity law</em>: <code>(m &gt;&gt;= f) &gt;&gt;= g</code> equates to <code>m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code></li>
</ul>
<h2 id="the-functor-laws-covariant-functor-laws">The Functor Laws (covariant functor laws)</h2>
<ul>
<li>The <em>identity law</em>: must transform the identity in the source category to the identity in the destination category.</li>
<li>The <em>compose law</em>: must transform the composition operator in the source category to the composition operator in the destination category.</li>
</ul>
<h2 id="the-applicative-laws-for-functions">## The Applicative Laws for functions</h2>
<h2 id="syntax-rules-for-do">Syntax rules for <code>do</code></h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span> { x }            <span class="op">--&gt;</span> x</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span> { x; <span class="op">&lt;</span>xs<span class="op">&gt;</span> }      <span class="op">--&gt;</span> x <span class="op">&gt;&gt;</span> <span class="kw">do</span> { <span class="op">&lt;</span>xs<span class="op">&gt;</span> }</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span> { a <span class="ot">&lt;-</span> x; <span class="op">&lt;</span>xs<span class="op">&gt;</span> } <span class="op">--&gt;</span> x <span class="op">&gt;&gt;=</span> a <span class="ot">-&gt;</span> <span class="kw">do</span> { <span class="op">&lt;</span>xs<span class="op">&gt;</span> }</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span> { <span class="kw">let</span> <span class="op">&lt;</span>declarations<span class="op">&gt;</span>; xs }</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">--&gt;</span> <span class="kw">let</span> <span class="op">&lt;</span>declarations<span class="op">&gt;</span> <span class="kw">in</span> <span class="kw">do</span> { xs }</span></code></pre></div>
<h2 id="implementation-of-return-bind-and-then">Implementation of <code>return</code>, <code>bind</code> and <code>then</code></h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span><span class="ot">  ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> a   <span class="ot">-&gt;</span> m a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> x <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> (x, s)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=)   ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>m <span class="op">&gt;&gt;=</span> k  <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s&#39;) <span class="ot">=</span> runState m s</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">in</span> runState (k a) s&#39;</span></code></pre></div>
<h2 id="functors-and-application">Functors and Application</h2>
<p><strong>Functors</strong>: Uniform action over a parametrized type, generalizing the map function on lists. A functor transforms one category into another category. Functors arise every time we write compatibility layers and adapters between different pieces of software. In Haskell, the Functor class only encompass the narrow case where the source and target categories are both categories of ordinary functions</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;$&gt;) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- map id       == id               identity</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- map (f . g)  == map f . map g    composition</span></span></code></pre></div>
<p><strong>Applicative</strong>: Map function in a context to the value in a context. Can be chained together. All Applicative instances must also be Functor instances.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> f a</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>When one uses a <strong>monad transformer</strong> itâ€™s possible appreciate that we are using a <strong>functor</strong> as an adapter layer between two categories: the base monadâ€™s Kleisli category and the transformed monadâ€™s Kleisli category.</p>
<p>The functor design pattern embodies a philosophy of programming that emphasizes: - compatibility over standardization - specialization over monolithic frameworks - short-term completion over future-proofing</p>
</body>
</html>
